---
alwaysApply: true
---

# Laravel + Next.js Best Practices

## General Principles

- **Always prefer CLI commands** over manual file operations when possible
- Use Laravel Artisan commands for scaffolding, migrations, and code generation
- Use Next.js CLI (npx/create-next-app) for frontend scaffolding
- Follow PSR-12 coding standards for PHP
- Follow ESLint/Prettier standards for JavaScript/TypeScript
- Write clean, maintainable, and testable code
- Use type hints and return types in PHP
- Use TypeScript for Next.js when possible
- **ALWAYS run linting and quality checks after each modification** to ensure everything is working as intended

## Post-Modification Quality Checks

**CRITICAL: After making any code modifications, you MUST perform the following checks:**

### Laravel Backend Checks
1. **Linting**: Run `./vendor/bin/pint --test` or `./vendor/bin/pint` to check/fix PHP code style
2. **Configuration**: Run `php artisan config:clear` if configuration files were modified
3. **Routes**: Run `php artisan route:list` to verify routes are properly registered
4. **Database**: Run `php artisan migrate:status` to verify migrations are in sync
5. **Syntax Check**: Run `php -l` on modified PHP files to check for syntax errors
6. **Tests**: Run `php artisan test` or `php artisan test --filter TestName` for affected areas

### Next.js Frontend Checks
1. **Linting**: Run `npm run lint` or `yarn lint` to check for ESLint errors
2. **Type Checking**: Run `npm run type-check` or `npx tsc --noEmit` if TypeScript is used
3. **Build Check**: Run `npm run build` to ensure the project builds without errors
4. **Formatting**: Run `npm run format` or `npx prettier --check` to verify code formatting

### General Checks
1. **Read Linter Errors**: Always use `read_lints` tool to check for any linting errors in modified files
2. **Verify Functionality**: Ensure the modified code works as intended
3. **Check Dependencies**: Verify any new dependencies are properly installed
4. **Environment**: Ensure environment variables are properly configured if needed

### Automated Check Workflow
After each modification, follow this workflow:
1. Check for linting errors using `read_lints` tool
2. Run appropriate linting commands for the modified files
3. Fix any issues found
4. Re-verify with linting tools
5. Confirm the application still works correctly

**Note**: These checks should be performed automatically after every code modification to catch issues early and maintain code quality.

## Laravel Best Practices

### Code Organization
- Follow Laravel's directory structure conventions
- Use Service classes for complex business logic (place in `app/Services/`)
- Use Repository pattern for complex data access (place in `app/Repositories/`)
- Keep controllers thin - delegate to services/repositories
- Use Form Requests for validation (`php artisan make:request`)
- Use Resource classes for API responses (`php artisan make:resource`)
- Use DTOs (Data Transfer Objects) for complex data structures

### Artisan Commands (Always use CLI)
- **Controllers**: `php artisan make:controller ControllerName --api --resource`
- **Models**: `php artisan make:model ModelName -m` (with migration)
- **Migrations**: `php artisan make:migration create_table_name_table`
- **Seeders**: `php artisan make:seeder SeederName`
- **Factories**: `php artisan make:factory FactoryName --model=ModelName`
- **Requests**: `php artisan make:request RequestName`
- **Resources**: `php artisan make:resource ResourceName`
- **Policies**: `php artisan make:policy PolicyName --model=ModelName`
- **Middleware**: `php artisan make:middleware MiddlewareName`
- **Jobs**: `php artisan make:job JobName`
- **Events**: `php artisan make:event EventName`
- **Listeners**: `php artisan make:listener ListenerName --event=EventName`
- **Commands**: `php artisan make:command CommandName`
- **Services**: `php artisan make:service ServiceName`

### Database & Migrations
- Always use migrations for database changes (`php artisan make:migration`)
- Use foreign key constraints and indexes appropriately
- Use `php artisan migrate:fresh --seed` for development resets
- Use `php artisan migrate:rollback` to undo migrations
- Never modify existing migrations in production - create new ones
- Use `Schema::table()` for altering existing tables
- Use `$table->foreignId()` for foreign keys
- Use `$table->timestamps()` and `$table->softDeletes()` appropriately

### Eloquent Models
- Use type hints for properties: `protected $casts = ['field' => 'type']`
- Use `$fillable` or `$guarded` (prefer `$fillable` for security)
- Define relationships explicitly with return types
- Use accessors and mutators when needed
- Use query scopes for reusable query logic
- Use `$hidden` or `$visible` for API responses
- Use `$appends` for computed attributes

### Controllers
- Keep controllers focused on HTTP concerns
- Use dependency injection for services
- Return JSON responses for APIs: `response()->json()`
- Use `Resource` classes for consistent API responses
- Use `FormRequest` for validation
- Use `authorize()` method in controllers when needed
- Return proper HTTP status codes

### API Development
- Use API Resources for consistent response formatting
- Use API versioning: `/api/v1/`, `/api/v2/`
- Implement proper error handling and status codes
- Use Laravel Sanctum for authentication
- Implement rate limiting: `Route::middleware('throttle:60,1')`
- Use CORS middleware appropriately
- Document APIs (consider Laravel API Documentation tools)

### Validation
- Use Form Requests for complex validation rules
- Use `$request->validate()` for simple validation
- Use custom validation rules: `php artisan make:rule RuleName`
- Use validation messages and attributes for better UX
- Validate at the request level, not in controllers

### Authentication & Authorization
- Use Laravel Sanctum for SPA authentication
- Use Policies for authorization: `php artisan make:policy`
- Use Gates for simple authorization checks
- Implement role-based access control (RBAC) properly
- Use middleware for route protection
- Hash passwords using `Hash::make()` or `bcrypt()`

### Caching
- Use cache for expensive operations
- Use `Cache::remember()` for caching queries
- Use cache tags when appropriate
- Clear cache after updates: `php artisan cache:clear`
- Use `php artisan config:cache` and `php artisan route:cache` in production

### Queues & Jobs
- Use queues for time-consuming tasks
- Use `php artisan make:job` to create jobs
- Use `dispatch()` or `dispatchSync()` appropriately
- Use `php artisan queue:work` for processing jobs
- Use `php artisan queue:listen` for development
- Implement proper error handling and retries

### Testing
- Write Feature tests for HTTP endpoints
- Write Unit tests for business logic
- Use factories for test data: `php artisan make:factory`
- Use `php artisan test` to run tests
- Use `php artisan test --filter TestName` for specific tests
- Aim for high test coverage
- Use database transactions in tests when possible

### Code Quality
- Use Laravel Pint for code formatting: `./vendor/bin/pint`
- Use `php artisan route:list` to see all routes
- Use `php artisan tinker` for interactive debugging
- Use `php artisan pail` for real-time log viewing
- Use `php artisan optimize` in production
- Use `php artisan config:clear` when changing config files

### Environment & Configuration
- Never commit `.env` files
- Use `config()` helper instead of `env()` in code
- Use environment-specific configuration files
- Use `php artisan config:cache` in production
- Use `php artisan config:clear` in development

### Security
- Use CSRF protection for forms
- Use `@csrf` in Blade templates
- Sanitize user input
- Use parameterized queries (Eloquent handles this)
- Use `Hash::make()` for passwords
- Use `bcrypt()` or `Hash::check()` for password verification
- Implement rate limiting
- Use HTTPS in production
- Validate and sanitize all inputs

## Next.js Best Practices

### Project Structure
- Use App Router (app directory) for new projects
- Use Pages Router only for existing projects or specific needs
- Organize components in `components/` directory
- Use `lib/` for utilities and helpers
- Use `hooks/` for custom React hooks
- Use `types/` for TypeScript type definitions
- Use `styles/` for global styles

### CLI Commands (Always use CLI)
- **Create project**: `npx create-next-app@latest project-name`
- **Add dependency**: `npm install package-name` or `yarn add package-name`
- **Run dev server**: `npm run dev` or `yarn dev`
- **Build**: `npm run build` or `yarn build`
- **Start production**: `npm start` or `yarn start`
- **Generate component**: Use CLI tools or create manually following conventions

### Components
- Use functional components with hooks
- Use TypeScript for type safety
- Keep components small and focused
- Use composition over inheritance
- Extract reusable logic into custom hooks
- Use proper prop types or TypeScript interfaces
- Implement proper error boundaries

### Data Fetching
- Use Server Components by default (App Router)
- Use `fetch()` with proper caching strategies
- Use `use client` directive only when needed
- Use React Server Components for data fetching when possible
- Use SWR or React Query for client-side data fetching
- Implement proper loading and error states

### API Routes
- Use Next.js API routes for backend endpoints
- Keep API routes in `app/api/` (App Router) or `pages/api/` (Pages Router)
- Use proper HTTP methods (GET, POST, PUT, DELETE)
- Implement proper error handling
- Use middleware for authentication/authorization
- Return proper status codes and JSON responses

### State Management
- Use React Context for simple global state
- Use Zustand or Redux Toolkit for complex state
- Use URL state for shareable state
- Use local state for component-specific state
- Avoid prop drilling - use context or state management

### Styling
- Use Tailwind CSS for utility-first styling
- Use CSS Modules for component-specific styles
- Use styled-components or emotion for styled components
- Use global styles sparingly
- Follow mobile-first responsive design
- Use CSS variables for theming

### Performance
- Use `next/image` for optimized images
- Use `next/link` for client-side navigation
- Implement code splitting with dynamic imports
- Use `React.memo()` for expensive components
- Optimize bundle size with `next/bundle-analyzer`
- Use `getStaticProps` and `getStaticPaths` for static generation
- Use `getServerSideProps` for server-side rendering when needed

### SEO & Metadata
- Use `metadata` API (App Router) or `Head` component (Pages Router)
- Implement proper meta tags
- Use structured data (JSON-LD)
- Implement Open Graph and Twitter Card metadata
- Use semantic HTML
- Implement proper sitemap and robots.txt

### Authentication
- Use NextAuth.js for authentication
- Implement proper session management
- Use middleware for protected routes
- Store tokens securely (httpOnly cookies)
- Implement proper logout functionality

### Environment Variables
- Use `.env.local` for local development
- Use `.env.production` for production
- Prefix client-side variables with `NEXT_PUBLIC_`
- Never commit sensitive environment variables
- Use `process.env` to access environment variables

### Testing
- Write unit tests for utilities and helpers
- Write integration tests for API routes
- Write component tests with React Testing Library
- Use Jest for testing framework
- Aim for good test coverage

## Laravel + Next.js Integration

### API Communication
- Use Laravel Sanctum for SPA authentication
- Implement CORS properly in Laravel
- Use consistent API response format
- Handle errors consistently
- Use axios or fetch for API calls
- Implement proper error handling on frontend

### Authentication Flow
- Use Laravel Sanctum for token-based auth
- Store tokens securely (httpOnly cookies recommended)
- Implement refresh token mechanism
- Handle token expiration gracefully
- Use middleware for protected routes

### File Structure
```
/var/www/html/crm/
├── backend/          # Laravel API
│   ├── app/
│   ├── config/
│   ├── database/
│   ├── routes/
│   └── ...
└── frontend/         # Next.js App (if separate)
    ├── app/
    ├── components/
    ├── lib/
    └── ...
```

### Development Workflow
- Run Laravel API: `cd backend && php artisan serve`
- Run Next.js: `cd frontend && npm run dev`
- Use concurrently for running both: `npm run dev` (if configured)
- Use environment variables for API URLs
- Use proxy in Next.js config for API calls in development

## CLI Usage Priority

**ALWAYS use CLI commands when available:**

1. **Laravel Artisan** for all Laravel operations
2. **Composer** for PHP dependencies
3. **NPM/Yarn** for JavaScript dependencies
4. **Next.js CLI** for Next.js operations
5. **Git** for version control
6. **Docker/Sail** if using containerization

**Examples:**
- ✅ `php artisan make:controller` instead of manually creating files
- ✅ `php artisan migrate` instead of running SQL manually
- ✅ `npm install` instead of manually editing package.json
- ✅ `npx create-next-app` instead of manual setup
- ✅ `php artisan route:list` to see routes
- ✅ `php artisan tinker` for debugging
- ✅ `composer require package` for PHP packages
- ✅ `npm run build` for building assets

## Code Style

### PHP (Laravel)
- Follow PSR-12 coding standards
- Use Laravel Pint: `./vendor/bin/pint`
- Use type hints and return types
- Use strict types: `declare(strict_types=1);`
- Use meaningful variable and method names
- Use camelCase for variables and methods
- Use PascalCase for classes

### JavaScript/TypeScript (Next.js)
- Use ESLint and Prettier
- Use TypeScript when possible
- Use camelCase for variables and functions
- Use PascalCase for components
- Use const/let, avoid var
- Use arrow functions when appropriate
- Use async/await over promises when possible

## Error Handling

### Laravel
- Use try-catch blocks appropriately
- Use Laravel's exception handling
- Log errors properly: `Log::error()`
- Return proper HTTP status codes
- Use validation errors for user input

### Next.js
- Use error boundaries for React errors
- Handle API errors gracefully
- Show user-friendly error messages
- Log errors appropriately
- Use proper HTTP status codes in API routes

## Documentation
- Write clear, concise comments
- Document complex logic
- Use PHPDoc for PHP functions/classes
- Use JSDoc for JavaScript functions
- Keep README files updated
- Document API endpoints
- Document environment variables

## Git Workflow
- Use meaningful commit messages
- Create feature branches
- Use conventional commits format
- Keep commits atomic
- Review code before merging
- Use `.gitignore` properly

## Performance
- Optimize database queries (use eager loading)
- Use caching appropriately
- Minimize API calls
- Optimize images and assets
- Use CDN for static assets
- Monitor and profile performance

## Security
- Never commit secrets or API keys
- Use environment variables
- Validate and sanitize all inputs
- Use HTTPS in production
- Implement proper authentication
- Use CSRF protection
- Keep dependencies updated
- Use parameterized queries
- Implement rate limiting

